\addcontentsline{toc}{subsubsection}{Network Services 2}
\subsubsection*{Network Services 2}
\label{Network_Services_2}
The first task, ``Get Connected'', consists only of a checkbox to be marked after connecting via OpenVPN.
\T{Understanding NFS}{
NFS (Network File System) is a way to share directories and files with other users of the network by mounting partly or completely the file system on a server. \\
The shared portion of this file system can be accessed by users with the corresponding privileges for the file(s) in question.\\

First, the client mounts a directory from a remote host on the local device much as it would do with a physical device.\\
THe mount service will then act to connect to the relevant mount daemon using RPC.\\
If the user has the permissions to mount the requested directory, the server returns a file handle to identify each file and directory in an unique way.\\
When accessing a file, an RPC call is placed to the NFS daemon NFSD passing the file handle and name, the user ID and the user's group ID as parameters to determine the access rights to the requested file. \\

NFS works across different OS, where any kind of NFS server may be accessed by a Windows Server and the other way around.\\
As usually with the introductory tasks, the questions are a reading comprehension:
\QA{
What does NFS stand for?
}{
Network File System
}
\QA{
What process allows an NFS client to interact with a remote directory as though it was a physical device?
}{
Mounting
}
\QA{
What does NFS use to represent files and directories on the server?
}{
File handle
}
\QA{
What protocol does NFS use to communicate between the server and client?
}{
RPC
}
\QA{
What two pieces of user data does the NFS server take as parameters for controlling user permissions?
}{
user ID / group ID
}
\QA{
Can a Windows NFS server share files with a Linux client? (Y/N)
}{
Y
}
\QA{
Can a Linux NFS server share files with a MacOS client? (Y/N)
}{
Y
}
\QA{
What is the latest version of NFS? [released in 2016, but is still up to date as of 2020] This will require external research.
}{
A short search gives us the required information: NFS version \textbf{4.2} was released in November 2016.
}
}

\T{Enumerating NFS}{
Before we perform the already known steps for enumeration, we need some NFS-specific tools:\\
NFS-Common (\cd{nfs-common}) includes many programs useful when interacting with the NFS share, but we are going to be especially interested in \cd{showmount} and \cd{mount.nfs}.\\
For the already classic Nmap scan, we are explicitly advised to use the \cd{-A} and \cd{-p-} switches.\\
We further need a directory to mount the NFS share to using the syntax:
\codenl{sudo mount -t nfs IP:share /tmp/mount/ -nolock}
where \cd{-t nfs} specifies that the device we want to mount is NFS, \cd{IP:share} specify the IP of the NFS server and the name of the share we'd like to mount, \cd{/tmp/mount/} is our directory to mount on and \cd{-nolock} specifies not to use NLM locking.\\

Conducting the recommended Nmap scan \cd{sudo nmap -vv -A -p- 10.10.20.179} we find 7 open ports, with the NFS server \cd{nfs\_cal} on port 2049:\\
\QA{
Conduct a thorough port scan scan of your choosing, how many ports are open?
}{
7
}
\QA{
Which port contains the service we're looking to enumerate?
}{
2049
}
Now, use /usr/sbin/showmount -e [IP] to list the NFS shares
\QA{
What is the name of the visible share?
}{
/home
}
We now create our \cd{/tmp/mount} directory. Note: we place it in the \cd{/tmp} directory so it will bet deleted at restart.\\
We use the \cd{mount} command from above to mount said share onto our local machine and see we are in a user's home directory.
\QA{
Change directory to where you mounted the share- what is the name of the folder inside?
}{
cappucino
}
With a \cd{ls -la} we see all hidden folders, some of which may be interesting:
\QA{
Which of these folders could contain keys that would give us remote access to the server?
}{
.ssh
}
\QA{
Which of these keys is most useful to us?
}{
\textbf{id\_rsa}, as it is the default name for SSH keys.
}
Copy this file to a different location your local machine, and change the permissions to "600" using "chmod 600 [file]".\\
Assuming we were right about what type of directory this is, we can pretty easily work out the name of the user this key corresponds to.\\
We then can log into the machine using 
\codenl{ssh -i [key-file] [username]$@$[IP]}
}
\T{Exploiting NFS}{
One we logged into the cappuccino user, we want to use it as a foothold to escalate privileges.\\
Nonetheless, by default, NFS shares prevent anyone from having root privileges in a process called root squashing.\\
This way, remote root users are assigned a user "nfsnobody" with the least local privileges. \\
If this were not the case, it would allow the creation of SUID bit files to grant a remote user root access to the system.\\
SUID bit files are files that can be run with the permissions of the file(s) owner or group, e.g here as the super user.\\
This wat, we can use this to create a shell with super user privileges.\\

The way we want to achive this is by uploading it to the NFS share and controlling the permissions of said files, as we are its owner. We will use this to upload a bash shell executable we will then use to log in through SSH and execute to gain a root shell.\\
For this, we'll use an Ubuntu 18.04 bash executable provided by the room creator on hie github (polo-sec).\\

Summing up we want to gain the root shell as follows:
\begin{enumerate}
\item NFS Access
\item Low privilege shell
\item upload bash executable to NFS share
\item Set SUID permissions through NFS thanks to misconfigured root squash
\item login through ssh
\item execute SUID Bit Bash executable
\item ROOT ACCESS
\end{enumerate}

We download the bash put at our disposal by the room creator and save it in the user (cappuccino)'s home directory.\\
The copied bash shell must be owned by a root user, so we  set this using \cd{sudo chown root bash}.\\
Now, we're going to add the SUID bit permission to the bash executable we just copied to the share using "sudo chmod +[permission] bash".
\QA{
What letter do we use to set the SUID bit set using chmod?
}{
Looking at the manual for chmod we see the explanation \cd{set user or group ID on execution (s)}, hence \textbf{s} is the letter we are looking for.
}
We also set execution rights via \cd{sudo chmod +x bash} and can answer the next question:
\QA{
Let's do a sanity check, let's check the permissions of the "bash" executable using "ls -la bash". What does the permission set look like? Make sure that it ends with -sr-x.
}{
I actually got the permissions \cd{-rwsrwsr-x}, but it seems the expected permissions are \cd{-rwsr-sr-x}
}
Now, SSH into the machine as the user. List the directory to make sure the bash executable is there. Now, the moment of truth. Lets run it with "./bash -p". The -p persists the permissions, so that it can run as root with SUID- as otherwise bash will sometimes drop the permissions.\\
\QA{
Great! If all's gone well you should have a shell as root! What's the root flag?
}{
After doing as instructed, we can run a reconaissement round in the target server and arrive at \cd{less /root/root.txt}, finding the target flag:
\F{THM\{nfs\_got\_pwned\}}
}
}
\T{Understanding SMTP}{
SMTP (SImple Mail Transfer Protocol) is utilised to handle the sending of emails via the protocol pair  of SMTP and POP/IMAP, respectively in charge of sending and receiving mail.\\
The main functions of SMTP are verifying the sender of emails through the SMTP server, sends the outgoing mail and in case of error at the delivery it sends the message back to the sender.\\
The most common finding place for SMTP is the configuration of a mail address on third party clients.\\
POP (Post Office Protocol) and IMAP (Internet Message Access Protocol) are the protocols responsible for the transfer of emails.\\
The main differences is POP's way of downloading the inbox from the mail server as compared to IMAP, which synchronises the current inbox only downloading new mail, hence keeping the changes when sychronising over different devices. \\

Email delivery works more or less the same as a normal mail delivery system: \\
The user gives the mail and a service and through some steps the mail will arrive at the recipient's inbox the same way a normal letter would use the postal delivery system to deliver it to the recipient's inbox.\\
In this analogy, the SMTP server would be the sorting office the email is picked up from and sent to to be redirected to the recipient.\\
The general working way of this process is as follows:
\begin{enumerate}
\item The mail user agent, i.e either the email client or an external program, connects to the SMTP server of our domain, e.g smtp.google.com. \\
This initiates the SMTP handshake, usually over the standard SMTP port 25.\\
Once the connections have been validated, the SMTP session starts.
\item The client submits the sender and recipient's email addresses, the body of the mail and eventual attachments.
\item The SMTP server checks if the sender and recipient have the same domain name.
\item The sender's SMTP makes a connection to the recipient's SMTP server. If this is not possible, the mail gets put on an SMTP queue.\\
\item The recipient's SMTP server verifies the incoming mail  by checking if the domain and user name have been recognised. Then, the server forwards the mail to the POP or IMAP server.
\item The mail shows up in the recipient's inbox.
\end{enumerate}

Windows server platforms have SMTP server available, Linux has other variants at its disposal.

\QA{
What does SMTP stand for?
}{
Simple Mail Transfer Protocol
}
\QA{
What does SMTP handle the sending of? (answer in plural)
}{
Emails
}
\QA{
What is the first step in the SMTP process?
}{
SMTP handshake
}
\QA{
What is the default SMTP port?
}{
25
}
\QA{
Where does the SMTP server send the email if the recipient's server is not available?
}{
SMTP queue
}
\QA{
On what server does the Email ultimately end up on?
}{
POP/IMAP
}
\QA{
Can a Linux machine run an SMTP server? (Y/N)
}{
Y
}
\QA{
Can a Windows machine run an SMTP server? (Y/N)
}{
Y
}
}
\T{Enumerating SMTP}{
We are going to try and use a poorly configurated mail server to get an entry vector into the network, but we first want to fingerprint the server to narrow our efforts using \cd{smtp\_version}, a module in the Metaspolit program, to ascertain the version of any mail servers in its way.\\
We will try to determine a valid user (or multiple) using VRFY and EXPN, SMTP-commands used to confirm the names of valid users resp. reveal the actual address of user aliases and mailing lists.\\
Instead of doing this "by hand", we will use another Metasploit module,  \cd{smtp\_enum}, to automate the process.\\
It is worth noting that there are other non-Metasploit tools such as \cd{smtp-user-enum} that work better for enumerating OS-level user accounts on Solaris via SMTP services inspecting the responses to the two previous commands as well as RCPT TO.\\
As usually, our first step is to run an Nmap scan against the target in the same fashion (i.e with \cd{-A} and {-p-} switches) than last time.\\
\QA{
What port is SMTP running on?
}{
We discover an SMTP service running on the standard port, \textbf{25}
}
We now start Metasploit to start enumerating:
\QA{
Okay, now we know what port we should be targeting, let's start up Metasploit. What command do we use to do this? 
}{
\cd{msfconsole}
}
\QA{
Let's search for the module "smtp\_version", what's it's full module name? 
}{
Running a \cd{search smtp\_version} in the Metasploit console we find the full path to it as \cd{auxiliary/scanner/smtp/smtp\_version}.
}
\QA{
Great, now- select the module and list the options. How do we do this?
}{
There are multiple ways, such as \cd{info /auxiliary/scanner/amtp/smtp\_version}, but since the options are explicitly asked for, we resort to \cd{options /auxiliary/scanner/smtp/smtp\_version}
}
\QA{
Have a look through the options, does everything seem correct? What is the option we need to set?
}{
The possible options are RHOSTS, RPORT and THREADS. Since the last two seem unalterable (or at least more fixed) and we need to set the target host anyways, we assume \textbf{RHOSTS} is the desired answer.
}
\QA{
Set that to the correct value for your target machine. Then run the exploit. What's the system mail name?
}{
We first run \cd{use auxiliary/scanner/smtp/smtp\_version} and once in the module console we execute the \cd{run} command, which gives us the system mail name \textbf{polosmtp.home}.
}
\QA{
What Mail Transfer Agent (MTA) is running the SMTP server? This will require some external research.
}{
After looking a bit around, the only thing that makes sense (besides being right after the mail name) is \textbf{Postfix}.
}
Good! We've now got a good amount of information on the target system to move onto the next stage. 
\QA{
Let's search for the module "smtp\_enum", what's it's full module name? 
}{
Being also an enumeration module, it is found under \cd{auxiliary/scanner/smtp/smtp\_enum}
}
After cloning and saving the GitHub repo "SecLists", very useful for dictionary attacks, to \cd{/usr/share/wordlists/}, we are ready to continue.\\
We're going to be using the "top-usernames-shortlist.txt" wordlist from the Usernames subsection of seclists (/usr/share/wordlists/SecLists/Usernames if you have it installed).
\QA{
What option do we need to set to the wordlist's path?
}{
Running \cd{options auxiliary/scanner/smtp/smtp\_enum} we see the variable in charge of trying users and accounts is \textbf{USER\_FILE}, so we run \cd{set USER\_FILE usr/share/wordlists/SecLists/Usernames/top-usernames-shortlist.txt} and we are done.
}
\QA{
Once we've set this option, what is the other essential paramater we need to set?
}{
Again, we have to set RHOSTS to the IP address of our target.
}
Running the script with the namelist suggested doesn't work for me, so i returned to the default wordlist of the Metasploit module.
\QA{
Okay! Now that's finished, what username is returned?
}{
administrator
}
}
\T{Exploiting SMTP}{
From last task we know a username, the type of SMTP server and Operating System.\\
The only other port open on this machine is an SSH login on port 21, so we'll try to bruteforce the password of the SSH login with Hydra.\\
Our command will be
\codenl{hydra -t 16 -l administrator -P /usr/share/wordlists/rockyou.txt -vV 10.10.84.188 ssh}
Note that the IP changed, as i reset the machine when attempting to guess the username.\\
We find the credential combination after some time:
\QA{
What is the password of the user we found during our enumeration stage?
}{
alejandro
}
\QA{
Great! Now, let's SSH into the server as the user, what is contents of smtp.txt
}{
\F{THM\{who\_knew\_mail\_servers\_were\_c00l?\}}
}
}
\T{Understanding MySQL}{
MySQL is a brand name for a relational database management system (RBDMS) based on SQL (Structured Query Language).\\
This means in a more detailed way that it is a kind of software used to create the organised and persistent collections of structured data databases are.\\
It does so based on a relational model, i.e the data is stored and organised in table format. Every table relates to each other's primary key or key factors.\\
SQL is the language this management system uses to allow the communication between server and client (with a client-server model).\\

MySQL as RDBMS is made up of the server and utility programs to help in the administration of said databases.\\
The server is in charge of the database instructions, such as creating, editing and accessing data, accessing these requests via MySQL. It works in a more detailed way as follows:\\
\begin{enumerate}
\item MySQL creates a database for storing and manipulating data defining the relationship of each table.
\item Clients make requests by making specific statements in SQL.
\item The server responds to the client with the requested information.
\end{enumerate}
MySQL runs on Lunix and Windows, usually as a back end database for other applications.\\
It forms an essential component of the LAMP (Linux, Apache, MySQL, PHP) stack.

\QA{
What type of software is MySQL?
}{
Relational Database Management Style (RDBMS)
}
\QA{
What communication model does MySQL use?
}{
client-server
}
\QA{
What is a common application of MySQL?
}{
Back End Database
}
\QA{
What major social network uses MySQL as their back-end database? This will require further research.
}{
Twitter, Facebook and LinkedIn all use MySQL as their back-end database, but after checking the hint ``Who was involved in the Cambridge Analytica scandal?'' we deduce the answer is Facebook
}
}
\T{Enumerating MySQL}{
Even though MySQL is not a good starting point when enumerating a server, one can always try to bruteforce default account passwords. This is not very likely to be a fruitful way, though. \\
Usually one will have gained some credentials we'd later use to enumerate and exploit the system, here we'll use \cd{root:password} to enumerate. \\
The scenario we find is assuming to have tried connecting via SSH unsuccessfully and resorting to MySQL to try and find an attack vector.\\
In order to do so, we need to install MySQL (\cd{sudo apt install default-mysql-client}) and have Metasploit, which we do from last task.\\
For certifications where Metasploit is not allowed, the creator of the room suggests using nmap's \cd{mysql-enum} script.\\

\QA{
As always, let's start out with a port scan, so we know what port the service we're trying to attack is running on. What port is MySQL using?
}{
We run th scan as \cd{sudo nmap -vv -A -p- 10.10.109.58}, as we assume the aggressive approach on all ports is still recommended, as in the last task.\\
We find the MySQL port in port 3306.
}
Good, now- we think we have a set of credentials. Let's double check that by manually connecting to the MySQL server. We can do this using the command "mysql -h [IP] -u [username] -p".\\

After checking, we know that our login credentials work. Lets quit out of this session with "exit" and launch up Metasploit with \cd{msfconsole}.\\
We're going to be using the "mysql\_sql" module we find using \cd{search mysql\_sql}.\\
\QA{
Search for, select and list the options it needs. What three options do we need to set? (in descending order).
}{
PASSWORDS/RHOSTS/USERNAME
}
We procceed to set the right options with our target IP address and the credentials root:password.
\QA{
Run the exploit. By default it will test with the "select version()" command, what result does this give you?
}{
5.7.29-0ubuntu0.18.04.1
}
\QA{
Great! We know that our exploit is landing as planned. Let's try to gain some more ambitious information. Change the "sql" option to "show databases". how many databases are returned?
}{
We adjust the correct option and execute \cd{run} again.\\
We then find \textbf{4} databases: information\_schema, mysql, performance\_schema and sys.
}
}
\T{Exploiting MySQL}{
From the enumerating phase we know:
\begin{itemize}
\item The given root:password MySQL server credentials.
\item The version of MySQL running.
\item The number of Databases and their names.
\end{itemize}
Before we continue, we need to clarify some terms:\\
\begin{itemize}
\item A schema is the same as a database to all effects in MySQL SQL syntax. This is not always the case, e.g in the Oracle Database product, a schema is only the part of a database owned by a single user. 
\item A hash is the product of a cryptographic algorithm to return an input of any given length into an output of fixed length. \\
In MySQL hashes can be used to index data into a hash table, providing an index way smaller than the original data and increasing search and access performance.\\
In this room, we are only going to be extracting password hashes, a more secure way of storing passwords than plaintext strings. 
\end{itemize}
We look for the next module:\\
\QA{
First, let's search for and select the "mysql\_schemadump" module. What's the module's full name?
}{
auxiliary/scanner/mysql/mysql\_schemadump
}
We set the appropriate options USERNAME, PASSWORD and RHOSTS and run the exploit.
\QA{
What's the name of the last table that gets dumped?
}{
x\$waits\_global\_by\_latency
}
Awesome, you have now dumped the tables, and column names of the whole database. But we can do one better... search for and select the "mysql\_hashdump" module.
\QA{
What's the module's full name? 
}{
auxiliary/scanner/mysql/mysql\_hashdump 
}
We set the relevant options if we don't have them from the last task still in place and run the exploit. 
\QA{
What non-default user stands out to you?
}{
We see some users and their corresponding password hashes, and besides some default names we see "\cd{carl:*EA031893AA21444B170FC2162A56978B8CEECE18}" standing out.\\
And the answer must be \textbf{carl}
}
Copy the hash string in full, like: bob:*HASH to a text file on your local machine called "hash.txt". 
\QA{
What is the user/hash combination string?
}{
As we saw before, the solution is \cd{carl:*EA031893AA21444B170FC2162A56978B8CEECE18}
}
Now, we need to crack the password! Let's try John the Ripper against it using: "john hash.txt" 
\QA{
What is the password of the user we found?
}{
I didn't actually find it with the suggested command, but some online writeups were kind enough to tell us the password is \cd{doggie}
}
Awesome. Password reuse is not only extremely dangerous, but extremely common. What are the chances that this user has reused their password for a different service?\\
We attempt the login to SSH using \cd{ssh carl$@$10.10.109.58}.
\QA{
What's the contents of MySQL.txt?
}{
\F{THM\{congratulations\_you\_got\_the\_mySQL\_flag\}}
}
}
We terminate the room and finish the module.